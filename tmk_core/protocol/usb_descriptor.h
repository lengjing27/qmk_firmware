/*
 * Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
 * This file is based on:
 *     LUFA-120219/Demos/Device/Lowlevel/KeyboardMouse
 *     LUFA-120219/Demos/Device/Lowlevel/GenericHID
 */

/*
                         LUFA Library
         Copyright (C) Dean Camera, 2012.

    dean [at] fourwalledcubicle [dot] com
                     www.lufa-lib.org
*/

/*
    Copyright 2012  Dean Camera (dean [at] fourwalledcubicle [dot] com)
    Copyright 2010  Denver Gingerich (denver [at] ossguy [dot] com)

    Permission to use, copy, modify, distribute, and sell this
    software and its documentation for any purpose is hereby granted
    without fee, provided that the above copyright notice appear in
    all copies and that both that the copyright notice and this
    permission notice and warranty disclaimer appear in supporting
    documentation, and that the name of the author not be used in
    advertising or publicity pertaining to distribution of the
    software without specific, written prior permission.

    The author disclaim all warranties with regard to this
    software, including all implied warranties of merchantability
    and fitness.  In no event shall the author be liable for any
    special, indirect or consequential damages or any damages
    whatsoever resulting from loss of use, data or profits, whether
    in an action of contract, negligence or other tortious action,
    arising out of or in connection with the use or performance of
    this software.
*/

/** \file
 *
 *  Header file for Descriptors.c.
 */
#ifndef _DESCRIPTORS_H_
#define _DESCRIPTORS_H_

#include <LUFA/Drivers/USB/USB.h>

#ifdef PROTOCOL_CHIBIOS
#    include "hal.h"
#endif

#ifdef WEBUSB_ENABLE
#include "WebUSBDevice.h"
#include "MS_OS_20_Device.h"
#define WEBUSB_VENDOR_CODE 0x42
#define WEBUSB_LANDING_PAGE_INDEX 0
#define MS_OS_20_VENDOR_CODE 0x45     // Must be different than WEBUSB_VENDOR_CODE
#define MS_OS_20_DESCRIPTOR_SET_TOTAL_LENGTH (10 + 20)	// Sum of `.Length`s in MS_OS_20_Descriptor in WebUSB.c
#define DTYPE_BOS 0x0F /**< Indicates that the descriptor is a Binary Object Store (BOS) descriptor. */
#define DTYPE_DeviceCapability 0x10 /**< Indicates that the descriptor is a Device Capability descriptor. */
#define DCTYPE_Platform 0x05 /**< Defines a device capability specific to a particular platform/operating system. */

   /** \brief Standard USB Binary Object Store (BOS) Descriptor (LUFA naming conventions).
			 *
			 *  Type define for a standard BOS Descriptor. This structure uses LUFA-specific element names
			 *  to make each element's purpose clearer.
			 *
			 *  \see \ref USB_StdDescriptor_BOS_t for the version of this type with standard element names.
			 *
			 *  \note Regardless of CPU architecture, these values should be stored as little endian.
			 */
			typedef struct
			{
				USB_Descriptor_Header_t Header; /**< Descriptor header, including type and size. */

				uint16_t TotalLength; /**< Length of this descriptor and all of its sub descriptors. */
				uint8_t NumberOfDeviceCapabilityDescriptors; /**< The number of separate device capability descriptors in the BOS. */
				uint8_t CapabilityDescriptors[]; /**< The combined bytes of the device capability descriptors */
			} ATTR_PACKED USB_Descriptor_BOS_t;

			/** \brief Standard USB Binary Object Store (BOS) Descriptor (USB-IF naming conventions).
			 *
			 *  Type define for a standard BOS Descriptor. This structure uses the relevant standard's given element names
			 *  to ensure compatibility with the standard.
			 *
			 *  \see \ref USB_Descriptor_BOS_t for the version of this type with non-standard LUFA specific element names.
			 *
			 *  \note Regardless of CPU architecture, these values should be stored as little endian.
			 */
			typedef struct
			{
				uint8_t  bLength; /**< Size of the descriptor, in bytes. */
				uint8_t  bDescriptorType; /**< Type of the descriptor, either a value in \ref USB_DescriptorTypes_t or a value
				                           *   given by the specific class.
				                           */
				uint16_t wTotalLength; /**< Length of this descriptor and all of its sub descriptors. */
				uint8_t  bNumDeviceCaps; /**< The number of separate device capability descriptors in the BOS. */
				uint8_t CapabilityDescriptors[]; /**< The combined bytes of the device capability descriptors */
			} ATTR_PACKED USB_StdDescriptor_BOS_t;

			/** \brief BOS_Descriptor generator macro.
			 *
			 *  Because BOS descriptors have variable length, a macro is needed to generate the bytes in order to
			 *  put them in PROGMEM.
			 *
			 *  \param[in]	seq	A 'sequence' of Capability Descriptors, presumably generated by other macros.
			 *
			 *  \note Each Capability Descriptor in the sequence should be a comma-separated list of bytes surrounded by parentheses.
			 *  e.g.
			 *  const USB_Descriptor_BOS_t PROGMEM BOSDescriptor = BOS_DESCRIPTOR(
			 *  	(WEBUSB_BYTES)	// #define WEBUSB_BYTES webusb_byte_0, webusb_byte_1, webusb_byte_2, ... , webusb_byte_24
			 *  	(byte0, byte1, byte2, ... , byteN)	// capability descriptor 2
			 *  );
			 */
			#define BOS_DESCRIPTOR(seq) _BOS_DESCRIPTOR(_BOS_DESCRIPTOR_COUNT(seq), _BOS_CAPABILITY_DESCRIPTORS(seq))

			/* BOS Device Capability Type Helper Macros */

				#define _BOS_L(...) 1 +
				#define _BOS_L_1(...) _BOS_L(__VA_ARGS__) _BOS_L_2
				#define _BOS_L_2(...) _BOS_L(__VA_ARGS__) _BOS_L_1
				#define _BOS_L_1_END 0
				#define _BOS_L_2_END 0
				#define _BOS_DESCRIPTOR_COUNT(seq) CONCAT_EXPANDED(_BOS_L_1 seq, _END)

				#define _APPEND(y, ...) __VA_ARGS__ ## y
				#define _APPEND_EXPANDED(y, x) _APPEND(y, x)

				#define _BOS_D(...) __VA_ARGS__,
				#define _BOS_D_1(...) _BOS_D(__VA_ARGS__) _BOS_D_2
				#define _BOS_D_2(...) _BOS_D(__VA_ARGS__) _BOS_D_1
				#define _BOS_D_1_END
				#define _BOS_D_2_END
				#define _BOS_CAPABILITY_DESCRIPTORS(seq) _APPEND_EXPANDED(_END, _BOS_D_1 seq)

				#define _BOS_DESCRIPTOR(COUNT, DESCRIPTORS) \
				{ \
					.Header = {.Size = sizeof(USB_Descriptor_BOS_t), .Type = DTYPE_BOS}, \
					.TotalLength = (sizeof((uint8_t[]){DESCRIPTORS}) + sizeof(USB_Descriptor_BOS_t)), \
					.NumberOfDeviceCapabilityDescriptors = (COUNT), \
					.CapabilityDescriptors = {DESCRIPTORS} \
				}
#endif

typedef struct
{
    USB_Descriptor_Configuration_Header_t Config;

#ifndef KEYBOARD_SHARED_EP
    // Keyboard HID Interface
    USB_Descriptor_Interface_t Keyboard_Interface;
    USB_HID_Descriptor_HID_t   Keyboard_HID;
    USB_Descriptor_Endpoint_t  Keyboard_INEndpoint;
#endif

#ifdef RAW_ENABLE
    // Raw HID Interface
    USB_Descriptor_Interface_t Raw_Interface;
    USB_HID_Descriptor_HID_t   Raw_HID;
    USB_Descriptor_Endpoint_t  Raw_INEndpoint;
    USB_Descriptor_Endpoint_t  Raw_OUTEndpoint;
#endif

#if defined(MOUSE_ENABLE) && !defined(MOUSE_SHARED_EP)
    // Mouse HID Interface
    USB_Descriptor_Interface_t Mouse_Interface;
    USB_HID_Descriptor_HID_t   Mouse_HID;
    USB_Descriptor_Endpoint_t  Mouse_INEndpoint;
#endif

#ifdef SHARED_EP_ENABLE
    // Shared Interface
    USB_Descriptor_Interface_t Shared_Interface;
    USB_HID_Descriptor_HID_t   Shared_HID;
    USB_Descriptor_Endpoint_t  Shared_INEndpoint;
#endif

#ifdef CONSOLE_ENABLE
    // Console HID Interface
    USB_Descriptor_Interface_t Console_Interface;
    USB_HID_Descriptor_HID_t   Console_HID;
    USB_Descriptor_Endpoint_t  Console_INEndpoint;
    USB_Descriptor_Endpoint_t  Console_OUTEndpoint;
#endif

#ifdef MIDI_ENABLE
    USB_Descriptor_Interface_Association_t Audio_Interface_Association;
    // MIDI Audio Control Interface
    USB_Descriptor_Interface_t          Audio_ControlInterface;
    USB_Audio_Descriptor_Interface_AC_t Audio_ControlInterface_SPC;
    // MIDI Audio Streaming Interface
    USB_Descriptor_Interface_t                Audio_StreamInterface;
    USB_MIDI_Descriptor_AudioInterface_AS_t   Audio_StreamInterface_SPC;
    USB_MIDI_Descriptor_InputJack_t           MIDI_In_Jack_Emb;
    USB_MIDI_Descriptor_InputJack_t           MIDI_In_Jack_Ext;
    USB_MIDI_Descriptor_OutputJack_t          MIDI_Out_Jack_Emb;
    USB_MIDI_Descriptor_OutputJack_t          MIDI_Out_Jack_Ext;
    USB_Audio_Descriptor_StreamEndpoint_Std_t MIDI_In_Jack_Endpoint;
    USB_MIDI_Descriptor_Jack_Endpoint_t       MIDI_In_Jack_Endpoint_SPC;
    USB_Audio_Descriptor_StreamEndpoint_Std_t MIDI_Out_Jack_Endpoint;
    USB_MIDI_Descriptor_Jack_Endpoint_t       MIDI_Out_Jack_Endpoint_SPC;
#endif

#ifdef VIRTSER_ENABLE
    USB_Descriptor_Interface_Association_t CDC_Interface_Association;
    // CDC Control Interface
    USB_Descriptor_Interface_t            CDC_CCI_Interface;
    USB_CDC_Descriptor_FunctionalHeader_t CDC_Functional_Header;
    USB_CDC_Descriptor_FunctionalACM_t    CDC_Functional_ACM;
    USB_CDC_Descriptor_FunctionalUnion_t  CDC_Functional_Union;
    USB_Descriptor_Endpoint_t             CDC_NotificationEndpoint;
    // CDC Data Interface
    USB_Descriptor_Interface_t CDC_DCI_Interface;
    USB_Descriptor_Endpoint_t  CDC_DataOutEndpoint;
    USB_Descriptor_Endpoint_t  CDC_DataInEndpoint;
#endif

#ifdef WEBUSB_ENABLE
    USB_Descriptor_Interface_t            WebUSB_Interface;
	USB_Descriptor_Endpoint_t             WebUSB_DataInEndpoint;
	USB_Descriptor_Endpoint_t             WebUSB_DataOutEndpoint;
#endif

} USB_Descriptor_Configuration_t;

/* Type Defines: */
#ifdef WEBUSB_ENABLE
/** Type define for the Microsoft OS 2.0 Descriptor for the device. This must be defined in the
 *  application code as the descriptor may contain sub-descriptors which can vary between devices,
 *  and which identify which USB drivers Windows should use.
 */
typedef struct
{
    MS_OS_20_Descriptor_Set_Header_t        Header;
    MS_OS_20_CompatibleID_Descriptor        CompatibleID;
} MS_OS_20_Descriptor_t;
#endif
/* index of interface */
enum usb_interfaces {
#ifndef KEYBOARD_SHARED_EP
    KEYBOARD_INTERFACE,
#else
#    define KEYBOARD_INTERFACE SHARED_INTERFACE
#endif

// It is important that the Raw HID interface is at a constant
// interface number, to support Linux/OSX platforms and chrome.hid
// If Raw HID is enabled, let it be always 1.
#ifdef RAW_ENABLE
    RAW_INTERFACE,
#endif

#if defined(MOUSE_ENABLE) && !defined(MOUSE_SHARED_EP)
    MOUSE_INTERFACE,
#endif

#ifdef SHARED_EP_ENABLE
    SHARED_INTERFACE,
#endif

#ifdef CONSOLE_ENABLE
    CONSOLE_INTERFACE,
#endif

#ifdef MIDI_ENABLE
    AC_INTERFACE,
    AS_INTERFACE,
#endif

#ifdef VIRTSER_ENABLE
    CCI_INTERFACE,
    CDI_INTERFACE,
#endif

#if defined(WEBUSB_ENABLE)
    WebUSB_INTERFACE,
#endif
    TOTAL_INTERFACES
};

#define NEXT_EPNUM __COUNTER__

/*
 * Endpoint numbers
 */
enum usb_endpoints {
    __unused_epnum__ = NEXT_EPNUM,  // Endpoint numbering starts at 1

#ifndef KEYBOARD_SHARED_EP
    KEYBOARD_IN_EPNUM = NEXT_EPNUM,
#else
#    define KEYBOARD_IN_EPNUM SHARED_IN_EPNUM
#endif

#if defined(MOUSE_ENABLE) && !defined(MOUSE_SHARED_EP)
    MOUSE_IN_EPNUM = NEXT_EPNUM,
#else
#    define MOUSE_IN_EPNUM SHARED_IN_EPNUM
#endif

#ifdef RAW_ENABLE
    RAW_IN_EPNUM  = NEXT_EPNUM,
    RAW_OUT_EPNUM = NEXT_EPNUM,
#endif

#ifdef SHARED_EP_ENABLE
    SHARED_IN_EPNUM = NEXT_EPNUM,
#endif

#ifdef CONSOLE_ENABLE
    CONSOLE_IN_EPNUM = NEXT_EPNUM,

#    ifdef PROTOCOL_CHIBIOS
    // ChibiOS has enough memory and descriptor to actually enable the endpoint
    // It could use the same endpoint numbers, as that's supported by ChibiOS
    // But the QMK code currently assumes that the endpoint numbers are different
    CONSOLE_OUT_EPNUM = NEXT_EPNUM,
#    else
#        define CONSOLE_OUT_EPNUM CONSOLE_IN_EPNUM
#    endif
#endif

#ifdef MIDI_ENABLE
    MIDI_STREAM_IN_EPNUM  = NEXT_EPNUM,
    MIDI_STREAM_OUT_EPNUM = NEXT_EPNUM,
#    define MIDI_STREAM_IN_EPADDR (ENDPOINT_DIR_IN | MIDI_STREAM_IN_EPNUM)
#    define MIDI_STREAM_OUT_EPADDR (ENDPOINT_DIR_OUT | MIDI_STREAM_OUT_EPNUM)
#endif

#ifdef VIRTSER_ENABLE
    CDC_NOTIFICATION_EPNUM = NEXT_EPNUM,
    CDC_IN_EPNUM           = NEXT_EPNUM,
    CDC_OUT_EPNUM          = NEXT_EPNUM,
#    define CDC_NOTIFICATION_EPADDR (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM)
#    define CDC_IN_EPADDR (ENDPOINT_DIR_IN | CDC_IN_EPNUM)
#    define CDC_OUT_EPADDR (ENDPOINT_DIR_OUT | CDC_OUT_EPNUM)
#endif
#ifdef WEBUSB_ENABLE
    WEBUSB_IN_EPNUM = NEXT_EPNUM,
    WEBUSB_OUT_EPNUM = NEXT_EPNUM,
#   define WEBUSB_IN_EPADDR (ENDPOINT_DIR_IN|WEBUSB_IN_EPNUM)
#   define WEBUSB_OUT_EPADDR (ENDPOINT_DIR_OUT|WEBUSB_OUT_EPNUM)
#endif
};

#ifdef PROTOCOL_LUFA
// LUFA tells us total endpoints including control
#    define MAX_ENDPOINTS (ENDPOINT_TOTAL_ENDPOINTS - 1)
#elif defined(PROTOCOL_CHIBIOS)
// ChibiOS gives us number of available user endpoints, not control
#    define MAX_ENDPOINTS USB_MAX_ENDPOINTS
#endif

// TODO - ARM_ATSAM

#if (NEXT_EPNUM - 1) > MAX_ENDPOINTS
#    error There are not enough available endpoints to support all functions. Please disable one or more of the following: Mouse Keys, Extra Keys, Console, NKRO, MIDI, Serial, Steno
#endif

#define KEYBOARD_EPSIZE             8
#define SHARED_EPSIZE               32
#define MOUSE_EPSIZE                8
#define RAW_EPSIZE                  32
#define CONSOLE_EPSIZE              32
#define MIDI_STREAM_EPSIZE          64
#define CDC_NOTIFICATION_EPSIZE     8
#define CDC_EPSIZE                  16
#ifdef WEBUSB_ENABLE
#define WEBUSB_EPSIZE               32
#endif

uint16_t get_usb_descriptor(const uint16_t wValue,
                            const uint16_t wIndex,
                            const void** const DescriptorAddress);

/* new API */
#if LUFA_VERSION_INTEGER < 0x140302
    #undef VERSION_BCD
    #define VERSION_BCD(Major, Minor, Revision) \
                                              CPU_TO_LE16( ((Major & 0xFF) << 8) | \
                                                           ((Minor & 0x0F) << 4) | \
                                                           (Revision & 0x0F) )
#endif

uint16_t get_usb_descriptor(const uint16_t wValue, const uint16_t wIndex, const void** const DescriptorAddress);
#endif
